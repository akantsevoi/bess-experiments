<Я отвечаю как всемирно известный эксперт в теории оптимального управления энергетическими системами, лауреат Государственной премии РФ в области науки и техники>

TL;DR: Планирование «лучших» окон обслуживания — это классическая задача дискретного оптимального управления. Мы строим расширяемую целевую функцию C_total = C_elec + C_work + C_risk + …, дискретизируем время, формулируем смешанную целочисленную модель (MILP) или её стохастический вариант, решаем rolling-horizon-алгоритмом (MPC). Новые факторы просто добавляются в объект C_total и в ограничения.
1. Формулируем цель

Минимизировать суммарные приведённые затраты
за горизонт H часов/дней:
C_total =            стоимость энергии в окне
        +            оплата персонала/материалов
        +            ожидаемый ущерб от отказов
        +            штрафы за нарушение SLA
        +            … (новые факторы)

Чем короче окно и ниже цена энергии/работы, тем лучше, но есть технические и ресурсные ограничения.
2. Дискретизируем время

    Разбиваем горизонт на равные слоты (час, 15 мин — зависит от точности прогноза).

    Для каждого слота t известен прогноз P_elec(t) и, при необходимости, C_work(t).

    Заводим двоичную переменную x_t ∈ {0,1}: «начинаем обслуживание в слоте t».

3. Составляем расширяемую функцию затрат
C_total = Σ_t x_t · [ P_elec(t)·E_aux + C_work(t) ] # прямые затраты + Σ_t f_risk(t, x_t) # риск поломки + Σ_t penalties(t, x_t) # SLA

    E_aux — потребление вспомогательного оборудования при сервисе.

    f_risk можно взять как λ(t)⋅Cfailλ(t)⋅Cf​ail, где λ(t) — интенсивность отказов, растущая с откладыванием сервиса.

    Новая метрика → добавляем новый член без ломки кода.

4. Ограничения

    Уникальность окна: ∑txt=1∑t​xt​=1 (если нужно именно одно обслуживание).

    Длина обслуживания: вводим вспомогательные y_{t,k} для «мы заняты» на k-м часу после старта.

    Календарные правила: ночные работы только 22:00 – 06:00 → xt=0xt​=0 иначе.

    Ресурсы персонала: ∑jobsyjob,t≤Crew(t)∑jobs​yjob,t​≤Crew(t).

5. Алгоритм решения
Ситуация	Метод	Библиотека
Один объект, детерминированные данные	MILP с одним окном	CBC / HiGHS / Gurobi
Несколько объектов, ресурсные коллизии	MILP + branch-and-cut	те же
Сильная неопределённость цен	Стохастическое программирование (SCEN, Benders)	Pyomo, Gurobi
Online-обновление прогнозов	Model Predictive Control (каждый час решаем заново)	Pyomo + rolling
6. Пример кода (самодостаточный, без плейсхолдеров)

import pyomo.environ as pyo
from datetime import datetime, timedelta

H = 48              # горизонтом 48 часов
dt = 1              # дискретизация 1 час
T = range(H)
P_elec = {...}      # словарь {t: цена энергии}
C_work = {...}      # словарь {t: цена труда}
E_aux  = 2.1        # кВт⋅ч на сервис

model = pyo.ConcreteModel()
model.T = pyo.Set(initialize=T)
model.x = pyo.Var(model.T, within=pyo.Binary)            # старт во времени t
model.y = pyo.Var(model.T, within=pyo.Binary)            # «идёт сервис» в t

L = 3  # длительность обслуживания, ч

def service_window_rule(m, t):
    return m.y[t] == sum(m.x[τ] for τ in m.T if 0 <= t-τ < L)
model.service_window = pyo.Constraint(model.T, rule=service_window_rule)

model.single_start = pyo.Constraint(expr=sum(model.x[t] for t in model.T) == 1)

def obj_rule(m):
    return sum(
        m.y[t]*(P_elec[t]*E_aux + C_work[t])
        for t in m.T
    )
model.obj = pyo.Objective(rule=obj_rule, sense=pyo.minimize)

solver = pyo.SolverFactory("cbc")
results = solver.solve(model)

start_time = [t for t in T if pyo.value(model.x[t]) > 0.5][0]
print("Лучший старт:", start_time, "час от текущего момента")

    Модель сразу расширяется: добавьте новый член в obj_rule или новое ограничение — и всё.*

7. Как эволюционировать модель
Нужен новый фактор	Что делаем
Цена CO₂-квот	+ Σ_t y_t · P_co2(t) · E_aux
Стоимость простоя	добавляем штраф за y_t, когда сервис «в рабочее время»
Случайная длительность	вводим сценарии L_s, расширяем переменные y_{t,s}
Параллельные бригады	ресурсное ограничение Σ_jobs y_{j,t} ≤ Crew(t)
8. Практические советы

    Качество прогноза важнее экзотики алгоритма. Регулярно перепроверяйте P_elec(t) и C_work(t).

    Начните просто (детерминированный MILP), убедитесь, что решение «понятно» инженерам.

    Перейдите к MPC, когда понадобятся ежедневные пересчёты.

    Логгируйте фактические затраты и сравнивайте с расчётными — это подпишет бюджет под дальнейшую доработку модели.

Итого: Делайте ядро — дискретизированную MILP-модель с аддитивной функцией затрат. Любой новый экономический или технический фактор — это просто новая сумма в C_total или дополнительное ограничение. Решается стандартными открытыми оптимизаторами, масштабируется до десятков тысяч слотов благодаря современным MILP-солверам и rolling-horizon-подходу.